# Тестовое задание от команды AI.Hardware

## Что было выполнено

С использование библиотеки [HardFloat](http://www.jhauser.us/arithmetic/HardFloat.html) был написан комбинационный модуль, складывающий два числа типа `float32`.
Библиотека использует 3-clause BSD лицензию и не имеет git репозитория, поэтому расположена прямо в этом репозитории.

## Тестбенч

Достать ModelSim сейчас непростая задача, поэтому для тестирования использовался [Icarus Verilog](https://github.com/steveicarus/iverilog).
При наличии исполняемых файлов `iverilog` и `vvp` в PATH собрать проект и запустить симуляцию можно с помощью команды:
```console
$ make
```
Путь к файлам `iverilog` и `vvp` определяются переменными make `IVERILOG` и `VVP` соответственно.

Для удобства запуск происходит в CI.

## Дизайн блока

Модуль имеет следующую сигнатуру:
```SystemVerilog
module f32_adder (
    input logic [31:0] a,
    input logic [31:0] b,
    output logic [31:0] c,
    output logic invalid,
    output logic overflow,
    output logic underflow,
    output logic inexact
);
```

Модуль принимает на вход два 32-битных вектора `a` и `b`, в которых должны содержаться числа, удовлетворяющие IEEE 754.
Выходом служит вектор `c`.
Кроме этого блок возвращает четыре флага:
- `invalid`, если выходное число некорректно, например результат `-NaN + NaN`
- `overflow`, если произошло переполнение
- `underflow`, если число получилось слишком маленьким (это случай я не смог протестировать, хотя кажется, что он может произойти и при сложении)
- `inexact`, если число не представимо точно в стандарте IEEE 754

Библиотека также возвращает флаг `infinite`, который означает деление на ноль.
При сложении такого произойти не может, поэтому было решено не возвращать его.

## Что под капотом

HardFloat имеет несколько внутренних представлений для чисел.
Данный блок конвертирует входные числа во внутреннее представление, в виде 33-битного вектора, затем складывает и конвертирует выход обратно.

Такая конструкция хороша, когда сложение чисел с плавающей запятой выполняется редко.
Если же это не так, то лучшим решением было бы хранение чисел в формате HardFloat повсеместно, с конвертацией в стандарт только в случае необходимости.
