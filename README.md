# Тестовое задание от команды интерконнекта

## Правила игры
(взято из текста)

### Описание интерфейса
| Сигнал | Ширина              | Направление     | Описание                           |
| ------ | ------------------- | --------------- | ---------------------------------- |
| valid  | 1                   | master -> slave | Запрос на передачу 1 пакета данных |
| ready  | 1                   | slave -> master | Готовность принять 1 пакет данных  |
| data   | задается параметром | master -> slave | Передаваемые данные                |
| valid  | 1                   | master -> slave | Флаг завершения транзакции         |

Протокол передачи данных
1. Данные передаются транзакциями
2. Одна транзакция может состоять из нескольких пакетов данных
3. Пакет считается переданным, если `valid` и `ready` установлены в единицу
4. Комбинационная зависимость сигнала `valid` от сигнала `ready` - запрещена
5. Сигнал `ready` может комбинационно зависеть от сигнала `valid`
6. Если сигнал `valid` установлен в 1, то сигналы, устанавливаемые master-устройством, не могут менять свое значение, пока не будет передан пакет данных
7. Для последнего из передаваемых в транзакции пакетов данных должен быть установлен сигнал `last`.

## Потоковый апсайзер
Интерфейс модуля
```SystemVerilog
module stream_upsize #(
    parameter int unsigned T_DATA_WIDTH = 1,
    parameter int unsigned T_DATA_RATIO = 2
) (
    input logic clk,
    input logic rst_n,
    input logic [T_DATA_WIDTH-1:0] s_data_i,
    input logic s_last_i,
    input logic s_valid_i,
    output logic s_ready_o,
    output logic [T_DATA_WIDTH-1:0] m_data_o[T_DATA_RATIO],
    output logic [T_DATA_RATIO-1:0] m_keep_o,
    output logic m_last_o,
    output logic m_valid_o,
    input logic m_ready_i
);
```

На вход модуля поступают транзакции размерности данных `T_DATA_WIDTH`.
Модуль должен выполнить их преобразование в транзакции размерностью `T_DATA_RATIO*T_DATA_WIDTH`, где `T_DATA_RATIO` - степень числа 2.
В одном выходном пакете данных может быть передано несколько слов данных.
Сигнал `m_keep_o` представляет собой набор флагов валидности данных.
Каждому слову сигнала `m_data_o` соответствует 1 бит валидности сигнала `m_keep_o`.
Если бит валидности слова равен 0, то такое слово является "нулевым" - не несет полезной информации.
Смешивать в одном выходном пакете данные разных входных транзакций - запрещено.


## Описание логики

Кроме входных и выходных сигналов нам потребуется счётчик `logic [T_DATA_WIDTH-1:0] counter`.

Блок имеет асинхронный сброс, и при его получении обнуляет `m_data_o`, `m_keep_o`, `m_last_o`, `m_valid_o`, `counter`, а `s_ready_o` выставляет в 1.

Первая проверка: готов ли master получать данные.
За это отвечает порт `m_ready_i`.
Если он равен 0, то выставляем флаг `s_ready_o` в 0 и ждем.
Если он равен 1, то продолжаем работу.

Если `s_ready_o` равен 0, то выставляем его, `m_valid_o` и `m_last_o` в 1 и ждем следующий цикл.

Если `m_valid_o` равен 1, то сбрасываем состояние как при получении сброса.

Если сигнал `s_valid_i` равен 0, то на этом цикле больше ничего не делаем.
Если же `s_valid_i` равен 1, то присваиваем `s_data_i` в `m_data_o[counter]` и `m_keep_o[counter]` в `1'b1`.
Кроме того, если `j == T_DATA_WIDTH-1`, то мы присваиваем счётчику значение 0, и выставляем `m_valid_o` в 1.
Если `j != T_DATA_WIDTH-1`, но `s_last_i` выставлен в 1, мы так же присваиваем счётчику и `s_ready_o` в 0.

### Примечания

Задержка в такой реализации равна `T_DATA_WIDTH-1`.

В зависимости от других требований возможно стоит использовать временные регистры для хранения результата, но так как в протоколе данное требование отсутствует, то вместо временных регистров используются выходные, т.к. реальное чтение из них происходит только при выставленном флаге `valid`.

И кажется где-то есть косяк, но я не вижу где :(.

## Реализация

Отсутствует ввиду недостатка времени.
Точнее то, которое находится в репозитории работает некорректно.
Реализацию другой задачи от команды AI.Hardware можно найти в ветке `rtl-task-1`.
